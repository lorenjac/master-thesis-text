# Serializing MVCC

The previous section introduced the MVCC protocol Snapshot Isolation. SI provides affordable isolation but fails to preclude all non-serializable schedules such as write skew. Nevertheless, SI is the most widely adopted MVCC implementation {larson2011high, neumann2015fast}. In some cases, serializing alternatives are available but disabled by default. This policy is often motivated by significant performance benefits compared to strictly serializing concurrency control {cahill2009serializable}. Others argue that SI anomalies may be negligible as even renowned ACID-compliant benchmarks such as TPC-C do not expose them {fekete2005making}. However, the need for data integrity should not be based on benchmarks failing to prove it. Therefore, there are efforts to overcome the weaknesses of SI and provide strong consistency without falling back to pessimistic approaches. This section presents an overview on approaches to making serializing MVCC affordable.

The main reason for non-serializable schedules in SI is that it cannot detect read-write conflicts. While SI keeps track of each transactions' updates for installment on commit, reads are not tracked. Therefore, a naive approach to achieve serializable schedules with SI is to track the read operations of each transaction. In doing so, read-write conflicts can be detected during validation by looking at the timestamps of all versions read. If at least one of these versions has been invalidated after the transaction started, then a read-write conflict has emerged. Unless the conflicting updater is still running, the reading transaction must abort. This method is both simple and effective but introduces significant overhead. Note that traditional SI does not perform any validation if first-updater-wins is used for precluding write-write conflicts. The additional overhead especially affects read-mostly transactions which is undesirable in read-dominated environments. Since the latter is where SI has been especially successful, tracking reads followed by validation is often stated as prohibitively expensive {cahill2009serializable}. Lacking viable alternatives, research interests primarily focus on mitigating the footprint of read tracking and validation.

### Exploiting Query Languages

Several authors have proposed to detect conflicts from query language statements {fekete2005making, faleiro2015rethinking, neumann2015fast}. For instance, a common strategy to prevent write skew in SI is to inject detectable conflicts whenever the required access patterns are detected {fekete2005making}. Others have found efficient ways to determine whether an item is included in a range query, thus improving validation time {neumann2015fast}. Although intriguing, these approaches cannot be applied to KVS since they operate through ad-hoc queries instead of query languages.

### Reducing Contention

A major challenge for high-performance implementations of MVCC and SI, in particular, is that important aspects such as timestamping or validation are often centralized which can cause considerable contention. Therefore, a substantial amount of research is dedicated to providing protocols in the spirit of SI but lower contention. Note that, in contrast to locking, contention for MVCC denotes much smaller intervals of a transaction's lifetime.

A major bottleneck in MVCC implementations is validation {tu2013speedy, bailey2013exploring, ding2015centiman, faleiro2015rethinking, wang2017efficiently, zhou2017posterior}. The reason is that, validation typically requires mutual exclusion since concurrent updates to items from the read set could falsify the validation result. As a result, validation does not scale, thus inhibiting transaction throughput. Therefore, many authors propose protocols featuring concurrent validation {bailey2013exploring, ding2015centiman, faleiro2015rethinking, wang2017efficiently}. Parallel validation has already been proposed in the early days of MVCC {kung81optimistic}, but received new interest lately.

Another point of contention is the assignment of timestamps. A typical SI implementation requires multiple timestamps for both versions and transactions. However, most implementations rely on a global assignment policy which introduces a significant contention on multi-core systems {tu2013speedy, zhou2017posterior}. First, concurrency is reduced as mutual exclusion is required to guarantee strictly monotone timestamps. Second, the CPU must be informed that changes to the cached timestamp counter must be globally visible. This is usually done with fences which can further reduce performance. In response, some authors have proposed protocols featuring decentralized timestamp assignment {tu2013speedy, zhou2017posterior}. Further sources of contention addressed in these works are transaction id assignment and shared memory access, in general.