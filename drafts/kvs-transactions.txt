Transactions are a powerful concept that has been adopted in various branches of computer science. With transactions, multiple operations, such as reading or updating a record, can be grouped into a single unit that succeeds if and only if neither of its operations fails. Especially in high-performance computing environments, the utilization of computing resources through concurrent transactions plays an essential role.

This section introduces the concept of transactions and its properties with regard to concurrency, in particular.

### Definition

A transaction is a sequence of operations that is treated as single atomic operation, i.e. it either succeeds if all its suboperations succeed or it fails. In general, an incomplete or failed transaction must not have any observable side effects. A transaction *commits* when all its subordinate operations have completed. Once this process is complete, the transaction is *committed* and all its side effects, if any, become visible.

In general, the concept of a transaction does not impose any restrictions on the kind of operation enclosed inside a transaction. That is, apart from primitive operations such as read or update, transactions may also consist of transactions as well. This concept is known as *nested* transactions. In contrast, only primitive operations are permitted for *flat* transactions. Since nested transactions are more complex in their nature and have not been widely adopted, they are not subject of this work {?}. Unless stated otherwise, the term transaction always refers to flat transactions.

Transactions are useful when a series of operations must either execute in conjunction or not at all. A simple example is the transfer of money from one bank account to another. The action of withdrawing and depositing a specified value comprises two separate actions that must be successful in conjunction or not at all. Still, as shown later, even single operations can benefit from transactional semantics.

### Transactional Semantics

The previous definition of transactions was of rather intuitive nature. However, in order to be useful the semantics of a transaction need to be described more precisely. The predominant characterization of transactional semantics is ACID {haerder1983}. It comprises a set of necessary properties:

* atomicity
* consistency
* isolation
* durability

Atomicity captures the notion of all-or-nothing, i.e. either all operations of a transactional context succeed or none at all. As a consequence, any already completed operation of a transaction must be undone if the latter fails. Reverting the affected data to their previous state is often referred to as *rollback*.

The property of consistency asserts that if the underlying data are in a consistent state, then any transaction must preserve consistency. For example, an ACID-compliant database cannot be transitioned into an illegal state by means of a transaction. If a transaction is bound to break the consistency of the database, then it has to be aborted and rolled back.

In case multiple transactions are executed concurrently, each transaction may observe intermediate side effects of other concurrent transactions. In order to prevent this scenario and ensure the consistency property, isolation precludes transactions from seeing any concurrent activity. The property of isolation is later dealt with in more detail.

The last of the four ACID properties is durability. It ensures that all side effects incurred by a committed transaction must be durable across any subsequent system failure. Durability can be very hard to enforce, especially in the face of catastropic failures with failing backup media. Therefore, its notion is usually relaxed to a practically reasonable extent.

The ACID properties have become the prevalent reference for characterizing transactional systems. However, not all systems enforce the complete set of properties. Notable examples are transactional memory for conventional RAM and some cache-like databases which do not support durability as they are volatile by design. In other cases, guarantees are not dropped but relaxed. As shown below, a prominent example for relaxation that is also fundamental to this thesis is the isolation of concurrent transactions.

### Concurrent Transactions

The performance of transaction processing systems such as databases is generally denoted by their transaction throughput, i.e. the number of transactions executed in a certain time frame. There are several approaches to increasing transaction throughput, one being concurrency. In theory, the throughput improvement on multi-core systems is linear in the number of available cores. However, there are several factors to consider, some of which are cache consistency and data integrity. Preserving both can have adverse effects on performance thus invalidating the above estimation. The following paragraph deals with data integrity as guaranteed by the isolation property in ACID.

When two or more transactions are run concurrently, race conditions on shared data are bound to occur. Race conditions on the other hand, may cause data conflicts which in turn can lead to inconsistent data. The possible conflicts are:

* write-write
* write-read
* read-write

When a transaction t1 attempts to update a record A that was previously written but not committed by another transaction t2 then t1's update could overwrite t2's update to A before it has become visible. This situation is called a *write-write* conflict.

t1: -------w(A)-commit---------
t2: --w(A)---- ... ----commit-- (t2's update is lost)

In a *write-read* conflict occurs when a transaction reads data from an update that has not been committed yet. Imagine a transaction t1 that reads a record A that was previously updated but not committed by another transaction t2. If t2 fails for some reason, then t1 could produce inconsistent data, e.g. by updating another record B based on A's value. This situation is also called *dirty read*.

t1: -------r(A)-w(B)-commit-- (B is inconsistent to committed A)
t2: --w(A)--- !!! ----------- (update to A was rolled back)

The last conflict is called *read-write* conflict and denotes a situation when a transaction updates a record that was previously read by another transaction that is still running. Consider two transactions t1, t2 where t1 reads a record A which is later updated before either transaction commits. If t1 reads A again, then the result may be inconsistent with the earlier read, hence the term *inconsistent read*.

t1: --r(A)--- ... ---r(A)--------- (has read inc. values of A)
t2: ----------w(A)--------commit-- 

It is important to note that the conflicts explained above are not precluded by protecting the individual read or update operations. With regard to data integrity it is imperative to ensure isolation by preventing these conflicts.

### Serializability

A core concept to preserve consistency in the presence of concurrent transactions is *serializability*.

* observation: given ACD, serial tx cannot cause inconsistencies
* idea: a concurrent schedule is valid if it behaves like serial
* implication: allow only concurrent schedules that produce the same output as a serial schedule would have
* need decidable classification of serial tx schedules
	* formal: a schedule is serializable if there is an equivalent serial schedule that produces the same output
	* problem: cannot check against all possible schedules each time
	* solution: 
		* identify and detect anomalies of non-serializable schedules
		* if an anomaly is detected than the involved tx must fail
		* all remaining schedules would be serializable
* SQL serializable {sql1992}
	* = absence of anomalies/phantoms
	* anomalies
		* lost update
		* phantom
	* isolation levels (degrees)
		* dirty read
		* non-repeatable read
		* serializable
* extension to SQL {berenson1998critique}
	* phantoms: 
		* read skew
		* write skew

### Transaction Models