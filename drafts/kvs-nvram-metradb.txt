In {marmol2016nonvolatile} KVS are proposed as a middleware for NVRAM. As an example the authors, present MetraDB, a solution for distributed storage based on NVRAM. Like NVHT, MetraDB is a single-level store which means that changes are written to NVRAM immediately. Since MetraDB is required to support overlapping namespaces, the KVS consists of multiple hash tables referred to as containers. While this seems to complicate memory allocation schemes for NVRAM, the authors assert that the size of hash tables is fixed. There are two kinds of transaction is MetraDB: transactions on containers and on meta data. Since containers are designed for single-threaded access, transactions on containers need not worry about isolation. In contrast, transactions on meta data can be multi-threaded. These transactions are responsible for adding and removing containers. The authors point out that these operations are infrequent and, therefore, need not be very efficient. For this reason, transactions on meta data are protected by a global lock on the collection of containers. Recovery is based on redo logging, since undo logging would require additional writes to NVRAM during a transactions. With redo logging, log entries only need to be flushed on commit which could be optimized, for example with non-temporal stores. In an evaluation, MetraDB has shown superior performance when compared to several lookup data structures contained in Intel's NVML. Given that NVML provides general-purpose NVRAM facilities, as opposed to MetraDB's use-case optimizations, the comparison is not always fair. Still, the evaluation exposes scalability issues related to the operating system rather than the KVS itself. Upon finding scalability to falter beyond more than 8 CPU cores, the authors present kernel locking on memory-mapped files as the cause.

When compared to Echo or NVHT, MetraDB is a very application-specific KVS. Especially, its use of containers, which can only be accessed by a one thread at a time, delivers little guidance for the design of a KVS with concurrent transactions. And while global locks or even single-threading are not uncommon in MMDB, the majority of systems aims for high concurrency {molina1992main}.