With NVRAM devices integrated into the system, programmers still need a way to access it. Several approaches have been proposed to this end {volos2017whisper}. While it is always possible to operate on NVRAM by mapping individual device regions into virtual memory, there are considerable weaknesses to this approach. A major challenge of working with NVRAM is to provide consistency guarantees across possible system failures. With raw device access which is already error-prone, the complex task of preserving consistency falls to the programmer. Another challenge is that virtual memory mappings are volatile and may no longer be valid after a restart.

Therefore, it has been proposed to rely on dedicated high-level programming primitives as in Mnemosyne, NV-Heaps, and NVML {volos2011mnemosyne, coburn2011nv_heaps, intel2017nvml}. These systems provide interfaces for memory allocation and consistent updates based on transactions. An important distinction to the previous low-level approach is that memory is accessed through an NVRAM-aware API instead of basic load and store statements. The difference is that the latter have no knowledge of non-volatile memory and its implications.

Another approach to manage NVRAM, that has been discussed, is through designated file systems {oukid2017data, andrei2017sap}. File systems provide a well-known and suitable abstraction for non-volatile storage. In order to enable regular memory access in a load-store manner, individual files can be mapped into virtual memory. However, traditional file systems are not directly well-suited for use with NVRAM. One reason is that most operating systems provide a page cache which is used by file systems to defer expensive disk IO. In the case of NVRAM, page caches may be no longer needed, as updates to NVRAM incur far less latency compared to other non-volatile memories. In this regard, page caches even add overhead instead of mitigating it. Apart from that, page caches add a level of indirection which makes writes to NVRAM more likely to be torn by failures. Also, traditional file systems are usually designed for block-oriented devices which may no longer be the best option. Therefore, several NVRAM-aware file systems have been proposed {condit2009better, wu2011scmfs, dulloor2014system, xu2016nova}. The key feature of these file systems is a zero-copy mechanism by circumventing page caches. This enables true store-load semantics for NVRAM when mapping files into virtual memory. Other aspects include attempts to leverage the byte-addressable nature of NVRAM and crash-related consistency issues.